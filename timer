#!/bin/bash
# timer - High-precision command timer (µs accuracy)
#
# USAGE:   timer [OPTIONS] <command> [args...]
#          source timer && timer -f <command>
#
# OPTIONS: -f  Human-readable format (1d 02h 34m 56.789s)
#          -j  JSON output with full timing data
#          -o  Output destination (default: stderr)
#
# FEATURES:
#   - Pure Bash, zero dependencies
#   - Microsecond precision via EPOCHREALTIME
#   - Preserves command exit status
#   - Dual-mode: script or sourceable library

# format_time_us <microseconds>
# Converts µs integer to human-readable string: "1d 02h 34m 56.789s"
# Units shown progressively (days only if >0, etc.)
format_time_us() {
  local -i remaining_us=$1
  local -i days hours minutes
  local -- output=''

  # Time constants in µs
  local -i -r day_us=86400000000 hour_us=3600000000 minute_us=60000000

  days=$((remaining_us / day_us))
  if ((days)); then
    output="${days}d "
    remaining_us=$((remaining_us - days * day_us))
  fi

  hours=$((remaining_us / hour_us))
  if ((hours || days)); then
    output="${output}$(printf '%02dh ' "$hours")"
    remaining_us=$((remaining_us - hours * hour_us))
  fi

  minutes=$((remaining_us / minute_us))
  if ((minutes || hours || days)); then
    output="${output}$(printf '%02dm ' "$minutes")"
    remaining_us=$((remaining_us - minutes * minute_us))
  fi

  # Seconds always shown; Xe-6 = scientific notation for µs→s conversion
  output="${output}$(printf '%.3fs' "${remaining_us}e-6")"
  echo "$output"
}
declare -fx format_time_us

# json_escape <string>
# Escapes string for JSON: \ " \n \t \r
json_escape() {
  local -- str=$1
  str=${str//\\/\\\\}
  str=${str//\"/\\\"}
  str=${str//$'\n'/\\n}
  str=${str//$'\t'/\\t}
  str=${str//$'\r'/\\r}
  echo "$str"
}
declare -fx json_escape

# timer [-f] [-j] [-o FILE] [--] <command> [args...]
# Times command execution with µs precision. Preserves exit status.
# Options: -f=formatted, -j=JSON, -o=output file, --=end options
# When sourced: -h/-V are noops; unknown options pass to command
timer() {
  local -- runtime output_to=/dev/stderr
  local -i formatted=0 json_output=0 errno=0

  # Parse options
  while (($#)); do
    case $1 in
      --)                shift; break ;;
      -f|--format)       formatted=1; shift ;;
      -j|--json)         json_output=1; shift ;;
      -o|--output-to)    shift; output_to=${1:-/dev/stderr}; shift ;;
      -h|--help|-V|--version) shift ;;  # Noop in function mode
      -[fjhV]?*)         set -- "${1:0:2}" "-${1:2}" "${@:2}"; continue ;;  # Split combined opts
      -*)                break ;;  # Unknown opt → part of command
      *)                 break ;;
    esac
  done

  # EPOCHREALTIME → integer µs (1234567890.123456 → 1234567890123456)
  local -i start_us=${EPOCHREALTIME//./}

  # Disable errexit during command execution, restore after
  local -i errexit_was_set=0
  [[ $- == *e* ]] && errexit_was_set=1 ||:
  set +e
  "$@"
  errno=$?
  ((errexit_was_set)) && set -e ||:

  local -i end_us=${EPOCHREALTIME//./}
  local -i elapsed_us=$((end_us - start_us))

  if ((json_output)); then
    # Build JSON: {elapsed_us, elapsed_s, elapsed_formatted, exit_code, command}
    local -- runtime_s cmd_json formatted_time arg
    local -i first=1
    runtime_s=$(printf '%.6f' "${elapsed_us}e-6")
    formatted_time=$(format_time_us "$elapsed_us")
    cmd_json='['
    for arg in "$@"; do
      ((first)) || cmd_json+=','
      first=0
      cmd_json+="\"$(json_escape "$arg")\""
    done
    cmd_json+=']'
    printf '\n{"elapsed_us":%d,"elapsed_s":%s,"elapsed_formatted":"%s","exit_code":%d,"command":%s}\n' \
      "$elapsed_us" "$runtime_s" "$formatted_time" "$errno" "$cmd_json" >>"$output_to"
  elif ((formatted)); then
    echo -e "\n# ${FUNCNAME[0]}: $(format_time_us "$elapsed_us")" >>"$output_to"
  else
    runtime=$(printf "%.6f" "${elapsed_us}e-6")
    echo -e "\n# ${FUNCNAME[0]}: ${runtime}s" >>"$output_to"
  fi

  return "$errno"
}
declare -fx timer


# Return here if sourced (functions already exported above)
[[ "${BASH_SOURCE[0]}" == "$0" ]] || return 0

# === Script Mode ===
set -euo pipefail
shopt -s inherit_errexit

declare -r VERSION=1.2.0
declare -r SCRIPT_NAME=${0##*/}

show_help() {
  cat <<HELP
$SCRIPT_NAME $VERSION - High-precision command timer

Usage: $SCRIPT_NAME [OPTIONS] <command> [args...]
       source $SCRIPT_NAME  # Load as library

Options:
  -f, --format          Human-readable: 1d 02h 34m 56.789s
  -j, --json            JSON output for scripting
  -o, --output-to FILE  Write to FILE (default: stderr)
  -h, --help            Show this help
  -V, --version         Show version

Combined short options: -fj (not with -o)

Examples:
  $SCRIPT_NAME sleep 1              # Basic timing
  $SCRIPT_NAME -f make -j4          # Formatted output
  $SCRIPT_NAME -j ./build.sh        # JSON for parsing
  $SCRIPT_NAME -o log.txt sleep 1   # Output to file

Library mode:
  source $SCRIPT_NAME
  timer -f mycommand arg1 arg2

Output: stderr (default), exit status preserved.
HELP
  exit "${1:-0}"
}

# Parse CLI arguments
declare -i formatted=0 json_output=0
declare -a cmd_args=()
declare -- output_to=/dev/stderr

(($#)) || >&2 show_help 1

while (($#)); do
  case $1 in
    --)           shift; cmd_args=("$@"); break ;;
    -f|--format)  formatted=1 ;;
    -j|--json)    json_output=1 ;;
    -o|--output-to) shift; output_to=${1:-/dev/stderr} ;;
    -h|--help)    show_help 0 ;;
    -V|--version) echo "$SCRIPT_NAME $VERSION"; exit 0 ;;
    -[fjhV]?*)    set -- "${1:0:2}" "-${1:2}" "${@:2}"; continue ;;
    -*)           >&2 echo "$SCRIPT_NAME: Invalid option ${1@Q}"; >&2 show_help 22 ;;
    *)            cmd_args=("$@"); break ;;
  esac
  shift
done

if ((${#cmd_args[@]} == 0)); then
  >&2 echo "$SCRIPT_NAME: No command specified"
  >&2 show_help 1
fi

# Run timer with collected options
declare -a timer_opts=(-o "$output_to")
((formatted==0)) || timer_opts+=(-f)
((json_output==0)) || timer_opts+=(-j)

timer "${timer_opts[@]}" "${cmd_args[@]}"
#fin
